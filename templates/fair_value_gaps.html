{% extends "base.html" %}
{% block title %}Fair Value Gaps Exam{% endblock %}
{% block content %}
<div class="container">
    <h2>Fair Value Gaps</h2>
    <p id="instructions">Part 1: Identify Bullish Fair Value Gaps (gaps above price where price has yet to return).</p>

    <!-- Progress indicator -->
    <div class="exam-progress">
        <span class="chart-indicator">Chart <span id="current-chart">{{ progress.chart_count|default(1) }}</span>/5</span>
        <div class="chart-progress-bar">
            <div class="chart-progress" style="width: {{ (progress.chart_count|default(1) / 5) * 100 }}%"></div>
        </div>
    </div>

    <!-- Chart and results container -->
    <div class="exam-container">
        <div class="chart-section">
            <h3 id="chart-symbol">Symbol: {{ symbol|default('Unknown') }} ({{ timeframe|default('Unknown') }})</h3>
            <div id="chart-container" style="position: relative; width: 800px; height: 600px;">
                <div id="chart" style="width: 100%; height: 100%;"></div>
                <div id="fvg-panel" class="panel">
                    <div class="panel-header">Fair Value Gaps</div>
                    <div id="fvg-list" class="panel-content"></div>
                </div>
            </div>
            
            <div class="toolbar mt-3">
                <button id="draw-rectangle" class="btn btn-primary">Draw FVG Rectangle</button>
                <button id="draw-hline" class="btn btn-info">Draw H-Line</button>
                <button id="undo-drawing" class="btn btn-warning">Undo</button>
                <button id="clear-drawings" class="btn btn-secondary">Clear Drawings</button>
                <button id="no-fvgs-button" class="btn btn-warning">No FVGs Found</button>
                <button id="toggle-theme" class="btn btn-dark">Toggle Light Mode</button>
                <button id="submit-btn" class="btn btn-success">Submit Answer</button>
                <button id="reset-exam" class="btn btn-danger">Reset Exam</button>
            </div>
        </div>
        
        <div id="results-section" class="results-section">
            <div class="results-header">
                <h3>Analysis Results</h3>
            </div>
            <div id="results-content" class="results-content">
                <!-- Results will be inserted here -->
            </div>
            <div class="results-footer">
                <button id="continue-btn" class="btn btn-success w-100">Continue</button>
            </div>
        </div>
    </div>
</div>

<div id="loading-overlay" class="loading-overlay">
    <div class="loading-content">
        <div class="spinner"></div>
        <div class="loading-text">Analyzing your answers...</div>
    </div>
</div>

<script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
<script>
    console.log("chartCount:", {{ progress.chart_count|default(1)|tojson|safe }});
    console.log("fvgPart:", {{ progress.fvg_part|default(1)|tojson|safe }});
    console.log("chartData:", {{ chart_data|tojson|safe }});

    let chartCount = Math.min({{ progress.chart_count|default(1)|tojson|safe }} || 1, 5);
    let fvgPart = {{ progress.fvg_part|default(1)|tojson|safe }} || 1; // 1 = bullish, 2 = bearish
    const maxCharts = 5;
    let chartScores = [];
    let chartData = {{ chart_data|tojson|safe }};
    let resultsData = null; // Store response data for reference
    
    // New tracking arrays for FVG visualization elements
    let fvgHoverAreas = [];
    let fvgLabels = [];
    let fvgLineSeries = [];
    let markers = [];
    
    // Function to check if chart data is valid
    function validateChartData(chartData) {
        if (!Array.isArray(chartData) || chartData.length < 20) {
            console.error(`Chart data invalid: ${chartData ? chartData.length : 0} candles`);
            return false;
        }
        
        // Check for too many identical candles (corrupted data)
        let identicalCandles = 0;
        let maxIdentical = 0;
        
        for (let i = 1; i < chartData.length; i++) {
            if (chartData[i].open === chartData[i-1].open && 
                chartData[i].high === chartData[i-1].high && 
                chartData[i].low === chartData[i-1].low && 
                chartData[i].close === chartData[i-1].close) {
                identicalCandles++;
            } else {
                identicalCandles = 0;
            }
            
            maxIdentical = Math.max(maxIdentical, identicalCandles);
        }
        
        if (maxIdentical > 5) {
            console.error(`Corrupted chart data: ${maxIdentical+1} identical candles in a row`);
            return false;
        }
        
        return true;
    }

    // Function to handle chart loading errors
    function handleChartError() {
        const loadingOverlay = document.getElementById('loading-overlay');
        loadingOverlay.classList.add('active');
        
        const loadingText = document.querySelector('.loading-text');
        loadingText.textContent = "Chart data issue detected. Fetching new chart...";
        
        // Try to get a new chart
        fetch('/fetch_new_chart')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (validateChartData(data.chart_data)) {
                    chartData = data.chart_data;
                    
                    // Reset the chart
                    candleSeries.setData([]);
                    
                    // Wait a short time before setting new data
                    setTimeout(() => {
                        candleSeries.setData(chartData);
                        document.getElementById('chart-symbol').textContent = 
                            `Symbol: ${data.symbol || 'Unknown'} (${data.timeframe || 'Unknown'})`;
                            
                        // Update FVG panel
                        clearAllDrawings();
                        updateFVGPanel();
                        
                        // Reset the zoom
                        chart.timeScale().resetTimeScale();
                        chart.timeScale().fitContent();
                        
                        loadingOverlay.classList.remove('active');
                    }, 500);
                } else {
                    // If the new data is also bad, show error message
                    alert("Unable to load valid chart data. Please refresh the page.");
                    loadingOverlay.classList.remove('active');
                }
            })
            .catch(error => {
                console.error('Error fetching new chart:', error);
                alert('Failed to load new chart. Please refresh the page.');
                loadingOverlay.classList.remove('active');
            });
    }
    
    if (!Array.isArray(chartData) || chartData.length === 0) {
        console.error("Invalid chart data, using fallback");
        chartData = [
            { time: 1710960000, open: 0.5, high: 0.51, low: 0.49, close: 0.505 },
            { time: 1710963600, open: 0.505, high: 0.515, low: 0.5, close: 0.51 }
        ];
        handleChartError(); // Try to get valid data immediately
    }

    const chart = LightweightCharts.createChart(document.getElementById('chart'), {
        width: 800,
        height: 600,
        layout: { 
            background: { color: '#1e1e1e' },
            textColor: '#d1d4dc'
        },
        grid: { 
            vertLines: { visible: false },
            horzLines: { visible: false }
        },
        timeScale: { timeVisible: true, secondsVisible: false },
        crosshair: {
            mode: LightweightCharts.CrosshairMode.Normal,
            vertLine: { visible: true, labelVisible: true },
            horzLine: { visible: true, labelVisible: true }
        }
    });
    const candleSeries = chart.addCandlestickSeries();
    candleSeries.setData(chartData);
    chart.timeScale().fitContent();

    let drawingMode = null; // 'rectangle', 'hline', or null
    let userFVGs = [];
    let rectangles = [];
    let hlines = [];
    let startPoint = null;
    let isLightMode = false;
    
    // FVG colors
    const colors = {
        bullish: 'rgba(76, 175, 80, 0.3)',
        bearish: 'rgba(244, 67, 54, 0.3)',
        correctBullish: 'rgba(255, 152, 0, 0.6)', // Changed to orange as requested
        correctBearish: 'rgba(244, 67, 54, 0.6)'
    };

    document.getElementById('toggle-theme').addEventListener('click', () => {
        isLightMode = !isLightMode;
        chart.applyOptions({
            layout: {
                background: { color: isLightMode ? '#ffffff' : '#1e1e1e' },
                textColor: isLightMode ? '#333333' : '#d1d4dc'
            }
        });
        document.getElementById('toggle-theme').textContent = isLightMode ? 'Toggle Dark Mode' : 'Toggle Light Mode';
    });

    function updateInstructions() {
        document.getElementById('instructions').textContent = 
            fvgPart === 1 ? 
            "Part 1: Identify Bullish Fair Value Gaps (gaps above price where price has yet to return)." :
            "Part 2: Identify Bearish Fair Value Gaps (gaps below price where price has yet to return).";
    }

    function updateFVGPanel() {
        const fvgList = document.getElementById('fvg-list');
        if (userFVGs.length === 0) {
            fvgList.innerHTML = '<p>No Fair Value Gaps marked yet.</p>';
            return;
        }
        
        // Check if "No FVGs Found" is marked
        if (userFVGs.length === 1 && userFVGs[0].no_fvgs_found) {
            fvgList.innerHTML = `
                <div class="fvg-item special-item">
                    <span class="fvg-label">No ${fvgPart === 1 ? 'Bullish' : 'Bearish'} FVGs Found</span>
                    <span class="fvg-advice">You've indicated that there are no fair value gaps in this chart.</span>
                </div>
            `;
            return;
        }
        
        fvgList.innerHTML = userFVGs.map((fvg, index) => {
            const startDate = new Date(fvg.startTime * 1000).toLocaleDateString();
            return `
                <div class="fvg-item">
                    <span class="fvg-label">FVG ${index + 1} (${fvg.type})</span>
                    <span class="fvg-range">Price Range: ${fvg.topPrice.toFixed(2)} - ${fvg.bottomPrice.toFixed(2)}</span>
                    <span class="fvg-date">Date: ${startDate}</span>
                </div>
            `;
        }).join('');
    }

    // Draw rectangle in the chart
    function drawRectangle(startTime, endTime, topPrice, bottomPrice, type = 'bullish') {
        const color = type === 'bullish' ? colors.bullish : colors.bearish;
        
        // Ensure startTime is less than endTime
        const [actualStartTime, actualEndTime] = startTime < endTime ? [startTime, endTime] : [endTime, startTime];
        
        // Add markers to indicate the start and end of the FVG
        const newMarkers = [
            {
                time: actualStartTime,
                position: 'inBar',
                color: color,
                shape: 'square',
                text: type === 'bullish' ? 'B-FVG Start' : 'S-FVG Start'
            },
            {
                time: actualEndTime,
                position: 'inBar',
                color: color,
                shape: 'square',
                text: type === 'bullish' ? 'B-FVG End' : 'S-FVG End'
            }
        ];
        
        const existingMarkers = candleSeries.markers() || [];
        candleSeries.setMarkers([...existingMarkers, ...newMarkers]);
        
        // Draw the top and bottom lines
        const topLine = candleSeries.createPriceLine({
            price: topPrice,
            color: color,
            lineWidth: 2,
            lineStyle: LightweightCharts.LineStyle.Solid,
            axisLabelVisible: true,
            title: `${type} FVG Top`
        });
        
        const bottomLine = candleSeries.createPriceLine({
            price: bottomPrice,
            color: color,
            lineWidth: 2,
            lineStyle: LightweightCharts.LineStyle.Solid,
            axisLabelVisible: true,
            title: `${type} FVG Bottom`
        });
        
        rectangles.push({
            startTime: actualStartTime,
            endTime: actualEndTime,
            topPrice: topPrice,
            bottomPrice: bottomPrice,
            type: type,
            markers: newMarkers,
            lines: [topLine, bottomLine]
        });
        
        return rectangles[rectangles.length - 1];
    }
    
    // Draw horizontal line in the chart
    function drawHLine(time, price, type = 'bullish') {
        const color = type === 'bullish' ? colors.bullish : colors.bearish;
        const title = type === 'bullish' ? 'Bullish FVG' : 'Bearish FVG';
        
        // Create price line
        const hline = candleSeries.createPriceLine({
            price: price,
            color: color,
            lineWidth: 2,
            lineStyle: LightweightCharts.LineStyle.Solid,
            axisLabelVisible: true,
            title: title
        });
        
        // Add marker at the line position
        const marker = {
            time: time,
            position: 'inBar',
            color: color,
            shape: 'circle',
            text: type === 'bullish' ? 'B' : 'S'
        };
        
        const existingMarkers = candleSeries.markers() || [];
        candleSeries.setMarkers([...existingMarkers, marker]);
        
        // Store the line data
        hlines.push({
            line: hline,
            time: time,
            price: price,
            type: type,
            marker: marker
        });
        
        return hlines[hlines.length - 1];
    }

    function removeLastDrawing() {
        if (rectangles.length > 0) {
            const lastRect = rectangles.pop();
            
            // Remove price lines
            if (lastRect.lines) {
                lastRect.lines.forEach(line => {
                    candleSeries.removePriceLine(line);
                });
            }
            
            // Update markers
            const currentMarkers = candleSeries.markers() || [];
            const updatedMarkers = currentMarkers.filter(marker => {
                return !lastRect.markers.some(m => 
                    m.time === marker.time && 
                    m.position === marker.position && 
                    m.text === marker.text
                );
            });
            
            candleSeries.setMarkers(updatedMarkers);
            return true;
        } else if (hlines.length > 0) {
            const lastLine = hlines.pop();
            candleSeries.removePriceLine(lastLine.line);
            
            // Update markers
            const currentMarkers = candleSeries.markers() || [];
            const updatedMarkers = currentMarkers.filter(marker => {
                return !(marker.time === lastLine.time && 
                        marker.position === lastLine.marker.position && 
                        marker.text === lastLine.marker.text);
            });
            
            candleSeries.setMarkers(updatedMarkers);
            return true;
        }
        return false;
    }

    function clearAllDrawings() {
        // Clear rectangles
        rectangles.forEach(rect => {
            if (rect.lines) {
                rect.lines.forEach(line => {
                    candleSeries.removePriceLine(line);
                });
            }
        });
        rectangles = [];
        
        // Clear horizontal lines
        hlines.forEach(line => {
            candleSeries.removePriceLine(line.line);
        });
        hlines = [];
        
        // Clear all markers
        candleSeries.setMarkers([]);
        
        // Clear user FVGs
        userFVGs = [];
        
        // Reset the no FVGs state
        resetNoFvgsState();
        
        // Update the FVG panel
        updateFVGPanel();
    }

    const panel = document.getElementById('fvg-panel');
    let isDragging = false;
    let currentX;
    let currentY;
    let xOffset = 0;
    let yOffset = 0;

    panel.addEventListener('mousedown', startDragging);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', stopDragging);

    function startDragging(e) {
        if (e.target.classList.contains('panel-header')) {
            isDragging = true;
            currentX = e.clientX - xOffset;
            currentY = e.clientY - yOffset;
        }
    }

    function drag(e) {
        if (isDragging) {
            e.preventDefault();
            xOffset = e.clientX - currentX;
            yOffset = e.clientY - currentY;
            const container = document.getElementById('chart-container');
            const maxX = container.offsetWidth - panel.offsetWidth;
            const maxY = container.offsetHeight - panel.offsetHeight;
            xOffset = Math.max(0, Math.min(xOffset, maxX));
            yOffset = Math.max(0, Math.min(yOffset, maxY));
            panel.style.left = xOffset + 'px';
            panel.style.top = yOffset + 'px';
        }
    }

    function stopDragging() {
        isDragging = false;
    }

    // Find candle by time
    function findCandleByTime(time) {
        return chartData.find(candle => candle.time === time);
    }

    // Toggle drawing modes
    document.getElementById('draw-rectangle').addEventListener('click', () => {
        drawingMode = drawingMode === 'rectangle' ? null : 'rectangle';
        document.getElementById('draw-rectangle').textContent = 
            drawingMode === 'rectangle' ? 'Stop Drawing' : 'Draw FVG Rectangle';
        
        if (drawingMode === 'rectangle') {
            document.getElementById('draw-hline').textContent = 'Draw H-Line';
        }
        
        // Reset the "No FVGs Found" state
        resetNoFvgsState();
        
        startPoint = null;
    });

    document.getElementById('draw-hline').addEventListener('click', () => {
        drawingMode = drawingMode === 'hline' ? null : 'hline';
        document.getElementById('draw-hline').textContent = 
            drawingMode === 'hline' ? 'Stop Drawing' : 'Draw H-Line';
        
        if (drawingMode === 'hline') {
            document.getElementById('draw-rectangle').textContent = 'Draw FVG Rectangle';
        }
        
        // Reset the "No FVGs Found" state
        resetNoFvgsState();
        
        startPoint = null;
    });

    document.getElementById('undo-drawing').addEventListener('click', () => {
        if (removeLastDrawing()) {
            if (userFVGs.length > 0) {
                userFVGs.pop();
                updateFVGPanel();
            }
        }
        
        // Reset the "No FVGs Found" state if no drawings remain
        if (userFVGs.length === 0) {
            resetNoFvgsState();
        }
    });

    document.getElementById('clear-drawings').addEventListener('click', () => {
        clearAllDrawings();
    });

    // Function to mark that no FVGs were found
    function markNoFvgsFound() {
        // Clear any existing drawings
        clearAllDrawings();
        
        // Add a special FVG entry that indicates "No FVGs Found"
        userFVGs = [{
            no_fvgs_found: true,
            type: fvgPart === 1 ? 'bullish' : 'bearish',
            startTime: chartData[0].time,
            endTime: chartData[chartData.length - 1].time,
            topPrice: 0,
            bottomPrice: 0
        }];
        
        // Update the FVG panel
        updateFVGPanel();
        
        // Visually indicate the choice
        const chartContainer = document.getElementById('chart-container');
        const noFvgOverlay = document.createElement('div');
        noFvgOverlay.id = 'no-fvg-overlay';
        noFvgOverlay.className = 'no-fvg-overlay';
        noFvgOverlay.innerHTML = `<div class="no-fvg-message">No ${fvgPart === 1 ? 'Bullish' : 'Bearish'} FVGs Found</div>`;
        
        // Remove any existing overlay
        const existingOverlay = document.getElementById('no-fvg-overlay');
        if (existingOverlay) {
            chartContainer.removeChild(existingOverlay);
        }
        
        chartContainer.appendChild(noFvgOverlay);
        
        // Disable drawing buttons
        document.getElementById('draw-rectangle').disabled = true;
        document.getElementById('draw-hline').disabled = true;
        document.getElementById('no-fvgs-button').disabled = true;
    }

    // Function to reset the "No FVGs Found" state
    function resetNoFvgsState() {
        // Re-enable drawing buttons
        document.getElementById('draw-rectangle').disabled = false;
        document.getElementById('draw-hline').disabled = false;
        document.getElementById('no-fvgs-button').disabled = false;
        
        // Remove the overlay
        const existingOverlay = document.getElementById('no-fvg-overlay');
        if (existingOverlay) {
            document.getElementById('chart-container').removeChild(existingOverlay);
        }
        
        // Reset userFVGs if it was set to "No FVGs Found"
        if (userFVGs.length === 1 && userFVGs[0].no_fvgs_found) {
            userFVGs = [];
            updateFVGPanel();
        }
    }

    // Add event listener for the "No FVGs Found" button
    document.getElementById('no-fvgs-button').addEventListener('click', markNoFvgsFound);
    
    document.getElementById('reset-exam').addEventListener('click', () => {
        if (confirm('Are you sure you want to reset the exam? This will clear all your progress.')) {
            // Force reset by clearing local data and redirecting through the exams page
            chartCount = 1;
            fvgPart = 1;
            chartScores = [];
            clearAllDrawings();
            document.getElementById('current-chart').textContent = "1";
            document.querySelector('.chart-progress').style.width = "20%";
            
            // Redirect through charting_exams to reset session
            fetch('/charting_exams')
                .then(() => window.location.href = '/charting_exam/fair_value_gaps');
        }
    });

    chart.subscribeClick((param) => {
        if (!drawingMode || !param.point) return;
        
        const price = candleSeries.coordinateToPrice(param.point.y);
        const time = chart.timeScale().coordinateToTime(param.point.x);
        
        const nearestCandle = findCandleByTime(time);
        
        if (!nearestCandle) {
            console.error('Could not find candle at time', time);
            return;
        }
        
        // Reset the "No FVGs Found" state if drawing
        resetNoFvgsState();
        
        if (drawingMode === 'rectangle') {
            if (!startPoint) {
                startPoint = { time: nearestCandle.time, price };
            } else {
                const fvgType = fvgPart === 1 ? 'bullish' : 'bearish';
                const topPrice = Math.max(startPoint.price, price);
                const bottomPrice = Math.min(startPoint.price, price);
                
                drawRectangle(startPoint.time, nearestCandle.time, topPrice, bottomPrice, fvgType);
                
                userFVGs.push({
                    startTime: startPoint.time,
                    endTime: nearestCandle.time,
                    topPrice: topPrice,
                    bottomPrice: bottomPrice,
                    type: fvgType
                });
                
                updateFVGPanel();
                startPoint = null;
            }
        } else if (drawingMode === 'hline') {
            const fvgType = fvgPart === 1 ? 'bullish' : 'bearish';
            drawHLine(nearestCandle.time, price, fvgType);
            
            userFVGs.push({
                startTime: nearestCandle.time,
                endTime: nearestCandle.time,
                topPrice: price,
                bottomPrice: price,
                type: fvgType
            });
            
            updateFVGPanel();
        }
    });

    // Function to create hover areas for FVG visualization
    // This approach uses div elements for more stable positioning
    function createFVGHoverAreas() {
        // Clear any existing hover areas and labels
        clearFVGVisualElements();
        
        // Skip if no results available
        if (!resultsData || !resultsData.expected || !resultsData.expected.gaps) return;
        
        // Sort gaps by top price (highest first) for numbering from top to bottom
        const sortedGaps = [...resultsData.expected.gaps].sort((a, b) => b.topPrice - a.topPrice);
        
        const chartContainer = document.getElementById('chart-container');
        
        // Create hover areas for each gap
        sortedGaps.forEach((gap, index) => {
            const fvgNumber = index + 1; // Start numbering from 1
            const color = gap.type === 'bullish' ? '#FF9800' : '#F44336';
            
            // Add gap lines that only extend to the right
            addGapLines(gap, fvgNumber, color);
            
            // Calculate the initial positions (will be updated in updateFVGPositions)
            const candleX = chart.timeScale().timeToCoordinate(gap.endTime);
            const topY = candleSeries.priceToCoordinate(gap.topPrice);
            const bottomY = candleSeries.priceToCoordinate(gap.bottomPrice);
            
            if (!candleX || !topY || !bottomY) return; // Skip if coordinates not available
            
            // Create hover area (invisible by default, matches the exact gap height)
            const hoverArea = document.createElement('div');
            hoverArea.className = 'fvg-hover-area';
            hoverArea.dataset.time = gap.endTime;
            hoverArea.dataset.topPrice = gap.topPrice;
            hoverArea.dataset.bottomPrice = gap.bottomPrice;
            hoverArea.dataset.fvgNumber = fvgNumber;
            hoverArea.dataset.type = gap.type;
            
            // Initial positioning (will be updated)
            hoverArea.style.position = 'absolute';
            hoverArea.style.left = (candleX) + 'px';
            hoverArea.style.top = topY + 'px';
            hoverArea.style.height = (bottomY - topY) + 'px';
            hoverArea.style.width = '20px'; // Small area for hover
            hoverArea.style.zIndex = '900';
            hoverArea.style.cursor = 'pointer';
            
            // Create label (hidden by default)
            const label = document.createElement('div');
            label.className = 'fvg-label';
            label.style.position = 'absolute';
            label.style.backgroundColor = color;
            label.style.color = 'white';
            label.style.padding = '2px 6px';
            label.style.borderRadius = '4px';
            label.style.fontWeight = 'bold';
            label.style.fontSize = '12px';
            label.style.zIndex = '1000';
            label.style.whiteSpace = 'nowrap';
            label.style.opacity = '0'; // Initially hidden
            label.style.transition = 'opacity 0.2s';
            label.style.pointerEvents = 'none'; // Prevent label from interfering with hover
            label.textContent = `Correct FVG ${fvgNumber}`;
            label.dataset.fvgNumber = fvgNumber;
            
            // Add hover events
            hoverArea.addEventListener('mouseenter', () => {
                label.style.opacity = '1';
            });
            
            hoverArea.addEventListener('mouseleave', () => {
                label.style.opacity = '0';
            });
            
            // Add to the DOM
            chartContainer.appendChild(hoverArea);
            chartContainer.appendChild(label);
            
            // Store references in the tracking arrays
            fvgHoverAreas.push(hoverArea);
            fvgLabels.push(label);
        });
        
        // Initial position update
        updateFVGPositions();
    }

    // Function to add gap lines (only extending to the right of the candle)
    function addGapLines(gap, fvgNumber, color) {
        try {
            // Create series for the top and bottom lines
            const topSeries = chart.addLineSeries({
                color: color,
                lineWidth: 2,
                lineStyle: 2, // Dashed
                lastValueVisible: false,
                priceLineVisible: false,
                crosshairMarkerVisible: false
            });
            
            const bottomSeries = chart.addLineSeries({
                color: color,
                lineWidth: 2,
                lineStyle: 2, // Dashed
                lastValueVisible: false,
                priceLineVisible: false,
                crosshairMarkerVisible: false
            });
            
            // Draw from the FVG end time to the right edge of the chart
            const rightEdge = Math.max(...chartData.map(d => d.time)) + 86400; // Add one day to ensure it reaches the edge
            
            // Set exactly two points to create a line
            topSeries.setData([
                { time: gap.endTime, value: gap.topPrice },
                { time: rightEdge, value: gap.topPrice }
            ]);
            
            bottomSeries.setData([
                { time: gap.endTime, value: gap.bottomPrice },
                { time: rightEdge, value: gap.bottomPrice }
            ]);
            
            // Store references to remove later
            fvgLineSeries.push(topSeries, bottomSeries);
        } catch (error) {
            console.error('Error adding gap lines:', error);
        }
    }

    // Function to update all FVG visual elements positions
    function updateFVGPositions() {
        // Skip if no chart or chartContainer
        const chartContainer = document.getElementById('chart-container');
        if (!chart || !chartContainer) return;
        
        // Check if we have coordinates
        if (!chart.timeScale().timeToCoordinate || !candleSeries.priceToCoordinate) return;
        
        // Calculate visible chart area
        const chartRect = chartContainer.getBoundingClientRect();
        const chartWidth = chartRect.width;
        const chartHeight = chartRect.height;
        
        // Update hover areas and labels
        for (let i = 0; i < fvgHoverAreas.length; i++) {
            const hoverArea = fvgHoverAreas[i];
            const label = fvgLabels.find(l => l.dataset.fvgNumber === hoverArea.dataset.fvgNumber);
            
            if (!hoverArea || !label) continue;
            
            try {
                const time = parseInt(hoverArea.dataset.time);
                const topPrice = parseFloat(hoverArea.dataset.topPrice);
                const bottomPrice = parseFloat(hoverArea.dataset.bottomPrice);
                
                if (isNaN(time) || isNaN(topPrice) || isNaN(bottomPrice)) continue;
                
                // Get coordinates from chart
                const candleX = chart.timeScale().timeToCoordinate(time);
                const topY = candleSeries.priceToCoordinate(topPrice);
                const bottomY = candleSeries.priceToCoordinate(bottomPrice);
                
                if (candleX === null || topY === null || bottomY === null) {
                    // Hide if out of view
                    hoverArea.style.display = 'none';
                    label.style.display = 'none';
                    continue;
                }
                
                // Update hover area position (exact height of the gap)
                hoverArea.style.display = '';
                hoverArea.style.left = candleX + 'px';
                hoverArea.style.top = topY + 'px';
                hoverArea.style.height = Math.max(1, bottomY - topY) + 'px'; // Ensure at least 1px height
                hoverArea.style.width = '20px'; // Fixed width for hover
                
                // Update label position (centered on the gap)
                label.style.display = '';
                const labelRect = label.getBoundingClientRect();
                const labelWidth = labelRect.width || 100; // Fallback width
                const labelHeight = labelRect.height || 20; // Fallback height
                
                // Calculate centered position
                const labelY = topY + (bottomY - topY) / 2;
                
                // Keep label within chart boundaries
                let labelX = candleX + 25; // 25px to the right of the hover area
                let adjustedY = labelY - (labelHeight / 2);
                
                // Boundary checks
                if (labelX + labelWidth > chartWidth) {
                    labelX = candleX - labelWidth - 5; // Position left of the hover area
                }
                
                if (adjustedY < 0) {
                    adjustedY = 0;
                } else if (adjustedY + labelHeight > chartHeight) {
                    adjustedY = chartHeight - labelHeight;
                }
                
                label.style.left = labelX + 'px';
                label.style.top = adjustedY + 'px';
            } catch (error) {
                console.error('Error updating FVG position:', error);
            }
        }
    }

    // Function to clear all FVG visual elements
    function clearFVGVisualElements() {
        // Clear hover areas
        fvgHoverAreas.forEach(area => {
            if (area && area.parentNode) {
                area.parentNode.removeChild(area);
            }
        });
        fvgHoverAreas = [];
        
        // Clear labels
        fvgLabels.forEach(label => {
            if (label && label.parentNode) {
                label.parentNode.removeChild(label);
            }
        });
        fvgLabels = [];
        
        // Remove line series with try/catch to prevent errors
        fvgLineSeries.forEach(series => {
            try {
                if (series && chart && typeof chart.removeSeries === 'function') {
                    chart.removeSeries(series);
                }
            } catch (error) {
                console.error('Error removing series:', error);
            }
        });
        fvgLineSeries = [];
    }

    // Completely reset all FVG visualization elements and data
    function resetFVGVisualization() {
        try {
            // Clear all visual elements
            clearFVGVisualElements();
            
            // Reset the results data
            resultsData = null;
            
            // Make sure other chart elements are reset properly
            markers = [];
            
            // Clear any custom line elements
            document.querySelectorAll('.custom-fvg-line').forEach(line => {
                if (line.parentNode) {
                    line.parentNode.removeChild(line);
                }
            });
        } catch (error) {
            console.error('Error in resetFVGVisualization:', error);
        }
    }

    // Replace the original drawFixedFVGLines function with our enhanced version
    function drawFixedFVGLines() {
        try {
            // Clear existing elements first
            clearFVGVisualElements();
            
            // Create new hover areas with labels
            createFVGHoverAreas();
            
            // Set up event listeners for chart movements
            setupChartEventListeners();
        } catch (error) {
            console.error('Error in drawFixedFVGLines:', error);
        }
    }

    // Set up all needed chart event listeners
    // Set up all needed chart event listeners - MINIMAL FIX VERSION
function setupChartEventListeners() {
    try {
        // Don't try to unsubscribe - this API doesn't support it
        // Just add new listeners which will override any existing ones
        
        // Subscribe to chart movements
        chart.timeScale().subscribeVisibleTimeRangeChange(updateFVGPositions);
        
        // Use try/catch for each subscription in case method doesn't exist
        try {
            chart.priceScale('right').subscribeVisiblePriceRangeChange(updateFVGPositions);
        } catch (e) {
            console.log('Price scale events not supported in this version');
        }
        
        chart.subscribeCrosshairMove(updateFVGPositions);
        
        // Also update on window resize
        window.removeEventListener('resize', updateFVGPositions);
        window.addEventListener('resize', updateFVGPositions);
    } catch (error) {
        console.error('Error in setupChartEventListeners:', error);
    }
}

    document.getElementById('submit-btn').addEventListener('click', () => {
        if (userFVGs.length === 0) {
            alert("Please mark at least one Fair Value Gap or use the 'No FVGs Found' button before submitting.");
            return;
        }

        document.getElementById('loading-overlay').classList.add('active');
        const loaderTimeout = setTimeout(() => {
            document.getElementById('loading-overlay').classList.remove('active');
        }, 5000);

        fetch('/charting_exam/validate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
                examType: 'fair_value_gaps',
                drawings: userFVGs,
                chartCount: chartCount,
                fvgPart: fvgPart
            })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('Server response:', data);
            resultsData = data;  // Store response data for reference
            
            // Clear any existing custom FVG lines
            document.querySelectorAll('.custom-fvg-line').forEach(line => line.remove());
            
            // Draw correct FVGs with custom lines that only extend right
            setTimeout(drawFixedFVGLines, 100);

            // Store the current chartCount at the time of submission
            const currentChart = chartCount;
            chartScores.push({
                chart: currentChart,  // Use the chartCount at submission time
                part: fvgPart,
                score: data.score,
                total: data.totalExpectedPoints
            });

            let resultsHtml = `
                <div class="results-summary">
                    <h4>Part ${fvgPart} Analysis <span class="analysis-score ${data.score > 0 ? 'good' : 'poor'}">${data.score}/${data.totalExpectedPoints}</span></h4>
                </div>
                <div class="score-statistics">
                    <div class="stat-row">
                        <span class="stat-label">Total gaps possible:</span>
                        <span class="stat-value neutral">${data.totalExpectedPoints}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Gaps identified:</span>
                        <span class="stat-value ${data.score > 0 ? 'good' : 'poor'}">${data.score}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Markings you made:</span>
                        <span class="stat-value neutral">${userFVGs.length}</span>
                    </div>
                </div>
                <div class="score-bar-container">
                    <div class="score-bar" style="width: ${data.totalExpectedPoints > 0 ? (data.score/data.totalExpectedPoints)*100 : 0}%"></div>
                </div>
            `;

            if (data.feedback && data.feedback.correct && Array.isArray(data.feedback.correct) && data.feedback.correct.length > 0) {
                resultsHtml += `
                    <div class="feedback-section correct-section">
                        <h4>Correctly Identified Gaps</h4>
                        <div class="feedback-grid">
                            ${data.feedback.correct.map((gap, index) => {
                                return `
                                    <div class="feedback-card">
                                        <span class="feedback-type ${gap.type === 'bullish' ? 'bullish' : (gap.type === 'bearish' ? 'bearish' : 'neutral')}">${gap.type === 'no_gaps' ? 'CORRECT' : gap.type.toUpperCase()}</span>
                                        <span class="feedback-price">${gap.type === 'no_gaps' ? '' : `Range: ${gap.topPrice ? gap.topPrice.toFixed(4) : 'N/A'} - ${gap.bottomPrice ? gap.bottomPrice.toFixed(4) : 'N/A'}`}</span>
                                        <p class="feedback-advice">${gap.advice || 'Good job!'}</p>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }

            const incorrectGaps = data.feedback && data.feedback.incorrect ? data.feedback.incorrect.filter(g => g.type !== 'missed_gap') : [];
            if (incorrectGaps.length > 0) {
                resultsHtml += `
                    <div class="feedback-section incorrect-section">
                        <h4>Incorrect Markings</h4>
                        <div class="feedback-grid">
                            ${incorrectGaps.map(gap => `
                                <div class="feedback-card">
                                    <span class="feedback-type incorrect">INCORRECT</span>
                                    <span class="feedback-price">${gap.type === 'no_gaps' || gap.type === 'missed_all_gaps' || gap.type === 'error' ? '' : `Range: ${gap.topPrice ? gap.topPrice.toFixed(4) : 'N/A'} - ${gap.bottomPrice ? gap.bottomPrice.toFixed(4) : 'N/A'}`}</span>
                                    <p class="feedback-advice">${gap.advice || 'This is not a fair value gap based on the three-candle pattern definition.'}</p>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            const missedGaps = data.feedback && data.feedback.incorrect ? data.feedback.incorrect.filter(g => g.type === 'missed_gap') : [];
            if (missedGaps.length > 0) {
                resultsHtml += `
                    <div class="feedback-section missed-section">
                        <h4>Missed Gaps</h4>
                        <div class="feedback-grid">
                            ${missedGaps.map(gap => `
                                <div class="feedback-card">
                                    <span class="feedback-type missed">MISSED</span>
                                    <span class="feedback-price">Range: ${gap.topPrice ? gap.topPrice.toFixed(4) : 'N/A'} - ${gap.bottomPrice ? gap.bottomPrice.toFixed(4) : 'N/A'}</span>
                                    <p class="feedback-advice">${gap.advice || 'You missed this fair value gap.'}</p>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            const resultsSection = document.getElementById('results-section');
            const resultsContent = document.getElementById('results-content');
            resultsContent.innerHTML = resultsHtml;
            resultsSection.classList.add('active');
            document.querySelector('.exam-container').classList.add('with-results');

            clearTimeout(loaderTimeout);
            document.getElementById('loading-overlay').classList.remove('active');
        })
        .catch(error => {
            console.error('Error submitting answer:', error);
            document.getElementById('loading-overlay').classList.remove('active');
            const resultsSection = document.getElementById('results-section');
            const resultsContent = document.getElementById('results-content');
            resultsContent.innerHTML = `
                <div class="error-message">
                    <h4>Error</h4>
                    <p>Failed to submit answer: ${error.message}</p>
                    <p>Please try again or refresh the page.</p>
                </div>
            `;
            resultsSection.classList.add('active');
            document.querySelector('.exam-container').classList.add('with-results');
        });
    });

    // Updated continue button handler
    // Updated continue button handler - fixed chart.series() error
    document.getElementById('continue-btn').addEventListener('click', function() {
    // Store the next_part value before clearing resultsData
    const hasNextPart = resultsData && resultsData.next_part === 2;
    
    // Clear any custom FVG lines and series
    markers.forEach(marker => {
        if (typeof marker.remove === 'function') {
            marker.remove();
        }
    });
    markers = [];
    
    // Clear all label elements
    document.querySelectorAll('.fvg-label').forEach(label => {
        if (label.parentNode) {
            label.parentNode.removeChild(label);
        }
    });
    
    // Remove any line series using our tracked fvgLineSeries array
    fvgLineSeries.forEach(series => {
        try {
            if (series && chart && typeof chart.removeSeries === 'function') {
                chart.removeSeries(series);
            }
        } catch (error) {
            console.error('Error removing series:', error);
        }
    });
    fvgLineSeries = [];
    
    // Check if we're at the end of the exam (5th chart, part 2)
    if (chartCount >= maxCharts && fvgPart === 2 && !hasNextPart) {
        console.log("Exam complete! This was chart 5 part 2");
        showFinalResults();
        return;
    }
    
    // Continue with the proper flow using the stored value
    if (hasNextPart) {
        console.log(`Moving to Part 2, chartCount: ${chartCount}`);
        fvgPart = 2;
        updateInstructions();
        clearAllDrawings();
        
        // Force chart refresh
        refreshChart();
    } else {
        console.log(`Part 2 complete, moving to next chart from ${chartCount}`);
        // Rest of your existing code for fetching new chart
        const loadingOverlay = document.getElementById('loading-overlay');
        loadingOverlay.classList.add('active');
        
        fetch('/fetch_new_chart')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                // Update chart count display - use server value
                chartCount = data.chart_count;
                document.getElementById('current-chart').textContent = chartCount;
                document.querySelector('.chart-progress').style.width = `${(chartCount / 5) * 100}%`;
                
                // Check if exam is complete 
                if (chartCount >= maxCharts) {
                    console.log("Last chart reached, this is chart 5 part 1");
                    // Don't show final results yet, need to do part 2 first
                }
                
                console.log(`Fetched new chart, chartCount: ${chartCount}`);
                
                // Reset FVG part and update instructions
                fvgPart = data.fvg_part || 1;
                updateInstructions();
                
                // Update chart data and symbol
                if (validateChartData(data.chart_data)) {
                    chartData = data.chart_data;
                    
                    // Reset the chart
                    candleSeries.setData([]);
                    
                    // Wait a short time before setting new data
                    setTimeout(() => {
                        candleSeries.setData(chartData);
                        document.getElementById('chart-symbol').textContent = 
                            `Symbol: ${data.symbol || 'Unknown'} (${data.timeframe || 'Unknown'})`;
                            
                        // Update FVG panel and clear drawings
                        clearAllDrawings();
                        updateFVGPanel();
                        
                        // Reset the zoom
                        chart.timeScale().resetTimeScale();
                        chart.timeScale().fitContent();
                        
                        // Update the continue button text on last chart
                        if (chartCount === maxCharts) {
                            document.getElementById('continue-btn').textContent = "Finish Exam";
                        }
                        
                        loadingOverlay.classList.remove('active');
                    }, 500);
                } else {
                    console.error("Invalid chart data received");
                    handleChartError();
                }
            })
            .catch(error => {
                console.error('Error fetching new chart:', error);
                loadingOverlay.classList.remove('active');
                alert('Failed to load the next chart. Please try again.');
            });
    }
    
    // Clear results data AFTER flow decision has been made
    resultsData = null;
    
    const resultsSection = document.getElementById('results-section');
    resultsSection.classList.remove('active');
    document.querySelector('.exam-container').classList.remove('with-results');
    panel.style.left = '10px';
    panel.style.top = '10px';
    xOffset = 10;
    yOffset = 10;
});
    // Simple refresh chart function without extra validations
    function refreshChart() {
        const currentData = candleSeries.data();
        if (Array.isArray(currentData) && currentData.length > 0) {
            candleSeries.setData([]);
            
            setTimeout(() => {
                candleSeries.setData(currentData);
                chart.timeScale().fitContent();
            }, 100);
        } else {
            console.error("Cannot refresh chart - data is invalid or empty");
        }
    }

    updateInstructions();
    updateFVGPanel();
    
    function showFinalResults() {
        // Create the final results view
        let totalScore = 0;
        let totalPossible = 0;
        
        chartScores.forEach(score => {
            totalScore += score.score;
            totalPossible += score.total;
        });
        
        const percentage = totalPossible > 0 ? (totalScore / totalPossible) * 100 : 0;
        let grade = "F";
        if (percentage >= 90) grade = "A";
        else if (percentage >= 80) grade = "B";
        else if (percentage >= 70) grade = "C";
        else if (percentage >= 60) grade = "D";
        
        // Hide chart and all other content
        document.querySelector('.chart-section').style.display = 'none';
        
        // Show results in full width
        const resultsSection = document.getElementById('results-section');
        resultsSection.classList.add('active');
        resultsSection.style.width = '100%';
        document.querySelector('.exam-container').classList.add('with-results');
        
        // Create final results content
        const resultsContent = document.getElementById('results-content');
        resultsContent.innerHTML = `
            <h2>Fair Value Gaps Exam Results</h2>
            <div class="final-score">
                <span class="final-score-value">Final Score: ${totalScore}/${totalPossible}</span>
                <span class="final-score-percentage">${percentage.toFixed(1)}% (Grade: ${grade})</span>
            </div>
            <div class="final-bar-container">
                <div class="final-bar" style="width: ${percentage}%"></div>
            </div>
            
            <div class="chart-breakdown">
                <h5>Performance by Chart</h5>
                <ul class="chart-scores">
                    ${chartScores.map((score, index) => `
                        <li class="chart-score-item">
                            <span class="chart-number">Chart ${Math.ceil((index + 1) / 2)}, ${index % 2 === 0 ? 'Bullish' : 'Bearish'}</span>
                            <span class="chart-score">${score.score}/${score.total}</span>
                            <div class="chart-mini-bar">
                                <div class="chart-mini-progress" style="width: ${(score.total > 0 ? (score.score / score.total) * 100 : 0)}%"></div>
                            </div>
                        </li>
                    `).join('')}
                </ul>
            </div>
            
            <div class="final-actions">
                <button id="restart-exam-btn" class="btn btn-primary">Restart Exam</button>
                <button id="return-home-btn" class="btn btn-secondary">Return to Home</button>
            </div>
        `;
        
        // Add event listeners for final action buttons
        document.getElementById('restart-exam-btn').addEventListener('click', () => {
            // Manually reset before redirect
            fetch('/charting_exams').then(() => {
                window.location.href = '/charting_exam/fair_value_gaps';
            });
        });
        
        document.getElementById('return-home-btn').addEventListener('click', () => {
            window.location.href = '/charting_exams';
        });
        
        // Update continue button
        const continueBtn = document.getElementById('continue-btn');
        continueBtn.textContent = "Download Results";
        continueBtn.onclick = function() {
            alert("Results download functionality would be implemented here.");
        };
    }

    // Add validation on initial load
    document.addEventListener('DOMContentLoaded', function() {
        if (!validateChartData(chartData)) {
            handleChartError();
        }
        
        // Also add this check after the chart is rendered
        setTimeout(() => {
            const chartContainer = document.getElementById('chart');
            if (chartContainer.clientHeight < 100 || !candleSeries.data() || candleSeries.data().length < 20) {
                console.error("Chart didn't render properly");
                handleChartError();
            }
        }, 1000);
    });

    // Handle resize to update custom FVG lines
    window.addEventListener('resize', function() {
        // Update FVG positions if results are available
        if (resultsData) {
            setTimeout(updateFVGPositions, 100);
        }
    });

    // Force a refresh after a short delay
    setTimeout(refreshChart, 500);
</script>

<style>
    .exam-progress {
        margin-bottom: 20px;
    }
    .chart-indicator {
        font-size: 1.2rem;
        margin-right: 10px;
    }
    .chart-progress-bar {
        width: 100%;
        height: 10px;
        background: #ddd;
        border-radius: 5px;
        overflow: hidden;
    }
    .chart-progress {
        height: 100%;
        background: #4CAF50;
        transition: width 0.3s ease;
    }
    .exam-container {
        display: flex;
        gap: 20px;
    }
    .chart-section {
        flex: 1;
    }
    .results-section {
        width: 300px;
        background: #f5f5f5;
        border-radius: 8px;
        padding: 20px;
        display: none;
    }
    .results-section.active {
        display: block;
    }
    .exam-container.with-results .chart-section {
        flex: 0 0 800px;
    }
    .results-header h3 {
        margin-top: 0;
    }
    .results-content {
        margin-bottom: 20px;
    }
    .results-summary h4 {
        margin: 0 0 10px;
    }
    .analysis-score.good {
        color: #4CAF50;
    }
    .analysis-score.poor {
        color: #F44336;
    }
    .score-statistics .stat-row {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
    }
    .stat-label {
        color: #666;
    }
    .stat-value.neutral {
        color: #333;
    }
    .stat-value.good {
        color: #4CAF50;
    }
    .stat-value.poor {
        color: #F44336;
    }
    .score-bar-container {
        width: 100%;
        height: 10px;
        background: #ddd;
        border-radius: 5px;
        margin: 10px 0;
    }
    .score-bar {
        height: 100%;
        background: #4CAF50;
        border-radius: 5px;
    }
    .feedback-section {
        margin-top: 15px;
        padding: 10px;
        border-radius: 5px;
    }
    .correct-section {
        background: #e8f5e9;
        border: 1px solid #4CAF50;
    }
    .incorrect-section {
        background: #ffebee;
        border: 1px solid #F44336;
    }
    .missed-section {
        background: #fff3e0;
        border: 1px solid #FF9800;
    }
    .feedback-section h4 {
        margin: 0 0 10px;
        font-size: 1.1rem;
    }
    .feedback-grid {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
    .feedback-card {
        background: #fff;
        padding: 8px;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
        gap: 4px;
    }
    .feedback-type {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 0.8rem;
        font-weight: bold;
        color: #fff;
    }
    .feedback-type.bullish {
        background: #4CAF50;
    }
    .feedback-type.bearish {
        background: #F44336;
    }
    .feedback-type.incorrect {
        background: #F44336;
    }
    .feedback-type.missed {
        background: #FF9800;
    }
    .feedback-type.neutral {
        background: #2196F3;
    }
    .feedback-price {
        font-size: 0.95rem;
        font-weight: 500;
        color: #333;
    }
    .feedback-advice {
        margin: 0;
        font-size: 0.85rem;
        color: #666;
        font-style: italic;
    }
    .final-score {
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
    }
    .final-score-value {
        font-size: 1.5rem;
        font-weight: bold;
    }
    .final-score-percentage {
        font-size: 1.5rem;
        color: #4CAF50;
    }
    .final-bar-container {
        width: 100%;
        height: 10px;
        background: #ddd;
        border-radius: 5px;
        margin-bottom: 20px;
    }
    .final-bar {
        height: 100%;
        background: #4CAF50;
        border-radius: 5px;
    }
    .chart-breakdown h5 {
        margin: 10px 0;
    }
    .chart-scores {
        list-style: none;
        padding: 0;
    }
    .chart-score-item {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
    }
    .chart-number {
        width: 150px;
    }
    .chart-score {
        width: 60px;
    }
    .chart-mini-bar {
        flex: 1;
        height: 5px;
        background: #ddd;
        border-radius: 3px;
    }
    .chart-mini-progress {
        height: 100%;
        background: #4CAF50;
        border-radius: 3px;
    }
    .final-actions {
        margin-top: 20px;
        display: flex;
        gap: 10px;
    }
    .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }
    .loading-overlay.active {
        display: flex;
    }
    .loading-content {
        background: white;
        padding: 20px;
        border-radius: 8px;
        text-align: center;
    }
    .spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #4CAF50;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        animation: spin 1s linear infinite;
        margin: 0 auto 10px;
    }
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    .panel {
        position: absolute;
        top: 10px;
        left: 10px;
        width: 200px;
        max-height: 200px;
        background: rgba(255, 255, 255, 0.9);
        border: 1px solid #ccc;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        z-index: 10;
        overflow-y: auto;
        font-size: 0.9rem;
    }
    .panel-header {
        background: #4CAF50;
        color: white;
        padding: 5px;
        text-align: center;
        cursor: move;
        font-weight: bold;
    }
    .panel-content {
        padding: 5px;
    }
    .fvg-item {
        margin-bottom: 5px;
        padding: 3px;
        border-bottom: 1px solid #eee;
    }
    .fvg-item:last-child {
        border-bottom: none;
    }
    .fvg-label {
        font-weight: bold;
        color: #333;
    }
    .fvg-range, .fvg-date {
        display: block;
        color: #666;
    }
    .no-fvg-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.2);
        display: flex;
        justify-content: center;
        align-items: center;
        pointer-events: none;
        z-index: 5;
    }
    .no-fvg-message {
        background-color: rgba(255, 255, 255, 0.8);
        padding: 10px 20px;
        border-radius: 5px;
        font-size: 18px;
        font-weight: bold;
        color: #333;
    }
    .special-item {
        background-color: #f8f9fa;
        border-left: 3px solid #ffc107;
    }
    .fvg-advice {
        font-style: italic;
        color: #6c757d;
        display: block;
        margin-top: 5px;
        font-size: 0.85rem;
    }
    .error-message {
        background-color: #ffebee;
        border: 1px solid #f44336;
        border-radius: 4px;
        padding: 15px;
        margin-bottom: 15px;
    }
    .error-message h4 {
        color: #d32f2f;
        margin-top: 0;
        margin-bottom: 10px;
    }
    .custom-fvg-line {
        pointer-events: none;
        z-index: 1000;
    }
    /* New styles for FVG hover areas */
    .fvg-hover-area {
        background-color: transparent;
    }
    
    .fvg-hover-area:hover {
        background-color: rgba(255, 255, 255, 0.1);
    }
    
    .fvg-label {
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
</style>
{% endblock %}